"""
Sources:
- https://developers.google.com/identity/oauth2/web/guides/how-user-authz-works
- https://medium.com/@vivekpemawat/enabling-googleauth-for-fast-api-1c39415075ea
- Google Gemini
"""
from fastapi import (
    HTTPException, 
    APIRouter, 
    Depends, 
    Request, 
    Response, 
    HTMLResponse
)
from fastapi.responses import RedirectResponse
from fastapi.security import OAuth2PasswordBearer
from application.features.auth.google_oauth import *
from application.features.auth.jwt_handler import create_jwt_token
from application.features.auth.crud import (
    get_user_email_by_id, 
    get_refresh_token_details,
    get_user_profile_picture_url, 
    get_user_role_names, 
    get_user_by_email,
    store_refresh_token,
    delete_refresh_token,
)
from typing import Dict, List
from application.features.auth.auth_helpers import (
    validate_user_email_login
)
from datetime import datetime
from application.features.auth.schemas import (
    UserLogin, 
    TokenResponse, 
    UserResponse
)
from application.features.auth.permissions import (
    require_user_access
)
from application.features.auth.gatech_saml2_helpers import (
    get_saml_client, # To get the initialized client
    prepare_saml_authn_request, # For /login/gatech
    process_saml_response, # For /gatech/saml2/acs
    generate_sp_metadata_xml # For /gatech/saml2/metadata
)


''' 
Prepend all student routes with /students and collect all student-relevant 
endpoints under Students tag in SwaggerUI
'''
router = APIRouter()
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")


@router.post("/login/email")
async def email_login(user_credentials: UserLogin) -> TokenResponse:
    """
    Log user in via email and password without SSO.
    """
    user_id = -1

    try:
        user_id = validate_user_email_login(
            user_credentials.email, 
            user_credentials.password
        )
    except HTTPException as e:
        raise e
    except Exception as e:
        print(f"Unexpected error during email login: {e}")
        raise HTTPException(
            status_code=500, 
            detail="An internal server error occurred."
        )
    
    # Get user roles to generate new access roles
    roles: List[str] = get_user_role_names(user_id)

    # Generate access token
    email = get_user_email_by_id(user_id)
    if not email:
        raise HTTPException(
            status_code=500, 
            detail="User email could not be retrieved after authentication."
        )
    
    profile_picture_url = get_user_profile_picture_url(user_id)
    
    access_token = create_jwt_token(
        {
            "user_id": user_id,
            "email": email,
            "roles": roles,
            "profile_picture_url": profile_picture_url
        },
        expires_delta=15
    )

    # Generate refresh token
    refresh_token = store_refresh_token(user_id) 

    return TokenResponse( 
        access_token=access_token,
        refresh_token=refresh_token,
        token_type="bearer",
    )


@router.get("/login/google")
async def google_login():
    """
    Retrieve Google SSO OAuth URL. Use to log user in with Google account.
    """
    backend_callback_uri = CONFIG["redirect_uris"][0]
    return { "google_auth_url": get_google_oauth_url(backend_callback_uri) }


@router.get("login/gatech")
async def gatech_login(request: Request):
    """
    Initiates SSO redirect to Georgia Tech for GT SSO login using SAML2 protocol.
    
    Source: Function generated by Google Gemini
    """
    # Check if IdP metadata is loaded before preparing request
    try:
        # We need to ensure saml_client is initialized before calling get_saml_client().
        # This will be handled by the lifespan event in main.py.
        # So we can safely proceed assuming it's initialized here.
        if not get_saml_client().metadata.identity_providers():
            raise HTTPException(
                status_code=500, 
                detail="SAML Identity Provider metadata not configured. Cannot initiate login."
            )

        # Use helper function to prepare the SAML request
        # The 'request.url' here will be the full URL including the /auth prefix
        redirect_url, _ = prepare_saml_authn_request(relay_state=str(request.url)) 
        
        print(f"Redirecting user to IdP for SAML authentication: {redirect_url}") 
        return RedirectResponse(url=redirect_url)

    except HTTPException: # Catch and re-raise HTTPException directly
        raise
    except Exception as e:
        print(f"Error during SAML login initiation: {e}") 
        raise HTTPException(
            status_code=500,
            detail=f"Failed to initiate SAML login: {e}"
        )


@router.post("/logout")
async def logout(
    refresh_token: str, 
    user_data: Dict = Depends(require_user_access)
) -> Dict[str, str]:
    """
    Logs user out of app by deleting refresh token from DB.
    """
    delete_refresh_token(refresh_token)
    return {"message": "Log-out successful."}


@router.post("/refresh_token")
async def refresh_access_token(refresh_token: str) -> TokenResponse:
    """
    Retrieves current refresh token and generates a new access token (JWT) with
    new expiration date.
    """
    token_details = get_refresh_token_details(refresh_token)
    if not token_details:
        raise HTTPException(status_code=401, detail="Invalid refresh token.")

    user_id = token_details["user_id"]
    expires_at = token_details["expires_at"]

    if expires_at < datetime.now():
        delete_refresh_token(refresh_token)
        raise HTTPException(
            status_code=401, 
            detail="Invalid or expired refresh token. Please log in again."
            )
    
    email = get_user_email_by_id(user_id)
    if not email:
        raise HTTPException(status_code=401, detail="User not found")
    
    roles = get_user_role_names(user_id)

    profile_picture_url = get_user_profile_picture_url(user_id)

    new_access_token = create_jwt_token(
        {
            "user_id": user_id,
            "email": email,
            "roles": roles,
            "profile_picture_url": profile_picture_url
        }
    )

    new_refresh_token = store_refresh_token(user_id)
    delete_refresh_token(refresh_token)

    return TokenResponse( 
        access_token=new_access_token,
        refresh_token=new_refresh_token,
        token_type="bearer",
    )


@router.get("/google/callback") 
async def google_auth_callback(code: str) -> TokenResponse: 
    """
    Handles callback from Google OAuth that redirects back to current app. 
    TODO: add in 400 status error for bad request, such as reusing old one-time token
    """
    backend_callback_uri = CONFIG["redirect_uris"][0]

    try:
        token_response_json = await exchange_code_for_token(
            code, backend_callback_uri)
        
        user_info = get_google_user_info(token_response_json["access_token"])

        email = user_info.get("email")

        if not email:
            raise HTTPException(
                status_code=403, 
                detail="No email passed back. Error from Google servers."
            )
        
        user = get_user_by_email(email)
        if not user:
            raise HTTPException(
                status_code=403, 
                detail="User does not exist in system."
            )

        
        user_id = user["id"]
        roles = get_user_role_names(user_id)

        profile_picture_url = get_user_profile_picture_url(user_id)

        access_token = create_jwt_token(
            {
                "user_id": user_id,
                "email": email,
                "roles": roles,
                "profile_picture_url": profile_picture_url
            }
        )
        
        refresh_token = store_refresh_token(user_id)

        return TokenResponse( 
            access_token=access_token,
            refresh_token=refresh_token,
            token_type="bearer",
        )
    except ValueError as ve:
        print(f"Google ID token verification failed: {ve}")
        raise HTTPException(
            status_code=401, 
            detail="Invalid Google ID token. Please try logging in again."
        )


@router.post("/gatech/saml2/acs")
async def gatech_assertion_consumer_service(request: Request) -> TokenResponse:
    """
    Receives and processes the SAML2 response from Georgia Tech.

    Source: Function generated by Google Gemini
    """
    try:
        form_data = await request.form()
        saml_response_b64 = form_data.get("SAMLResponse")

        if not saml_response_b64:
            print("No SAMLResponse found in ACS POST data.")
            raise HTTPException(status_code=400, detail="SAMLResponse missing.")

        # Use helper function to process the SAML response
        authn_response = process_saml_response(saml_response_b64)

        if authn_response is None:
            print("Failed to parse SAML authentication response.")
            raise HTTPException(status_code=400, detail="Invalid SAML response.")

        # Check for authentication errors and assertion validity
        if authn_response.assertion is None or not authn_response.successful():
            # Access errors from client via helper
            errors = get_saml_client().get_errors() 
            error_reason = get_saml_client().get_last_error_reason() 
            print(f"SAML authentication failed. Errors: {errors}. Reason: {error_reason}") 
            raise HTTPException(
                status_code=401,
                detail=f"SAML authentication failed: {error_reason}"
            )

        user_attributes: Dict = authn_response.ava
        print(f"SAML Authentication successful. Attributes: {user_attributes}")

        email = None
        if user_attributes.get("email"): # Common attribute name
            email = user_attributes["email"][0]
        elif user_attributes.get("mail"): # Another common attribute name
            email = user_attributes["mail"][0]
        # TODO: Coordinate with Georgia Tech IdP on expected attribute names.
        # Add more checks if you expect other OIDs or attribute names
        # Example: if user_attributes.get("urn:oid:0.9.2342.19200300.100.1.3"): email = user_attributes["urn:oid:0.9.2342.19200300.100.1.3"][0]

        if not email:
            print("SAML response did not contain a recognizable email attribute.")
            raise HTTPException(
                status_code=500, 
                detail="SAML response missing required email attribute."
            )
        
        user = get_user_by_email(email)
        if not user:
            print(f"User with email {email} from SAML not found in database.")
            raise HTTPException(
                status_code=403, 
                detail="User does not exist in system or is not authorized via Gatech SSO."
            )

        user_id = user["id"]
        roles: List[str] = get_user_role_names(user_id)
        profile_picture_url: str = get_user_profile_picture_url(user_id)

        access_token = create_jwt_token(
            {
                "user_id": user_id,
                "email": email,
                "roles": roles,
                "profile_picture_url": profile_picture_url
            }
        )
        refresh_token = store_refresh_token(user_id)

        return TokenResponse(
            access_token=access_token,
            refresh_token=refresh_token,
            token_type="bearer",
        )

    except HTTPException:
        raise
    except Exception as e:
        print(f"Unexpected error during SAML ACS processing: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"An internal server error occurred during SAML processing: {e}"
        )


@router.get("/gatech/saml2/metadata", response_class=HTMLResponse) # This will be /auth/gatech/saml2/metadata
async def gatech_saml_metadata_endpoint():
    """
    Exposes the Service Provider (SP) metadata XML.
    This is mainly for convenience; typically you'd generate and provide this file out-of-band.
    """
    try:
        metadata_xml = generate_sp_metadata_xml()
        return Response(content=metadata_xml, media_type="application/xml")
    except Exception as e:
        print(f"Error generating SP metadata XML: {e}")
        raise HTTPException(
            status_code=500,
            detail=f"Failed to generate SP metadata: {e}"
        )


@router.get("/me", response_model=UserResponse)
async def get_current_user(
    user_data: Dict = Depends(require_user_access)
) -> UserResponse:
    """
    Retrieve identifying and access data for current user. 
    """
    email = user_data.get("email")
    id = user_data.get("user_id")
    roles = user_data.get("roles")
    profile_picture_url = user_data.get("profile_picture_url")

    if not email or not id or not roles:
        raise HTTPException(
            status_code=401, 
            detail="Invalid token payload: missing email, user_id, or roles."
        )
    
    user = get_user_by_email(email)
    if not user:
        raise HTTPException(
            status_code=404, 
            detail="User found in token but not in database"
        )

    return UserResponse(
        id=id,
        email=email,
        roles=roles,
        first_name=user["first_name"],
        last_name=user["last_name"],
        school_email=email,
        profile_picture_url=profile_picture_url
    )